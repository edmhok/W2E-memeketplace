{"version":3,"file":"static/js/2229.d45b8c22.chunk.js","mappings":"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","sources":["hooks/swap/v2/index.ts","constants/v2.ts","store/swapv2/liquidity/hooks.ts","utils/swap/getTickToPrice.ts","utils/swap/maxAmountSpend.ts","utils/swap/mint.ts"],"sourcesContent":["import { useMemo, useCallback, useEffect, useState } from \"react\";\nimport { parseTokenAmount, formatTokenAmount, numberToString } from \"@w2e/utils\";\nimport { type NumberType } from \"@w2e/types\";\nimport { getTokenStandard, useUpdateTokenStandard } from \"store/token/cache/hooks\";\nimport { getPoolTokenStandard, getPoolCanisterId } from \"hooks/swap/v2/useSwapCalls\";\nimport { FeeAmount, Token } from \"@w2e/swap-sdk\";\n\nexport function useActualSwapAmount(amount: NumberType | undefined, currency: Token | undefined): string | undefined {\n  return useMemo(() => {\n    if (!amount || !currency) return undefined;\n\n    const typedValue = formatTokenAmount(amount, currency.decimals);\n    const fee = currency.transFee;\n\n    if (typedValue.isGreaterThan(currency.transFee)) {\n      return numberToString(parseTokenAmount(typedValue.minus(fee), currency.decimals));\n    }\n    return \"0\";\n  }, [amount, currency]);\n}\n\nexport function useUpdatePoolTokenStandardCallback() {\n  const updateTokenStandard = useUpdateTokenStandard();\n\n  return useCallback(async (poolId: string, tokenId: string) => {\n    if (!getTokenStandard(tokenId)) {\n      const standard = await getPoolTokenStandard(poolId, tokenId);\n      updateTokenStandard({ canisterId: tokenId, standard });\n    }\n  }, []);\n}\n\nexport function usePoolCanisterId(\n  token0CanisterId: string | undefined | null,\n  token1CanisterId: string | undefined | null,\n  fee: FeeAmount | undefined | null,\n) {\n  const poolKey = useMemo(() => {\n    return token0CanisterId && token1CanisterId && fee\n      ? `${token0CanisterId}_${token1CanisterId}_${String(fee)}`\n      : undefined;\n  }, [token0CanisterId, token1CanisterId, fee]);\n\n  const [poolCanisterId, stePoolCanisterId] = useState(\"\");\n\n  useEffect(() => {\n    const call = async () => {\n      if (token0CanisterId && token1CanisterId && fee && poolKey && !poolCanisterId) {\n        const poolCanisterId = await getPoolCanisterId(token0CanisterId, token1CanisterId, fee);\n        stePoolCanisterId(poolCanisterId);\n      }\n    };\n\n    call();\n  }, [poolCanisterId, token0CanisterId, token1CanisterId, fee, poolKey]);\n\n  return useMemo(() => poolCanisterId, [poolCanisterId]);\n}\n","export const DISABLE_ADD_LIQUIDITY_IDS = [\n  \"ew2hr-oaaaa-aaaan-qcycq-cai\",\n  \"m4mib-siaaa-aaaan-qaucq-cai\",\n  \"4ch4l-viaaa-aaaan-qa3bq-cai\",\n  \"uldch-7yaaa-aaaan-qa2wq-cai\",\n  \"2d2yc-biaaa-aaaan-qa4ka-cai\",\n];\n\nexport const DISABLE_SWAP_IDS = [\n  \"ew2hr-oaaaa-aaaan-qcycq-cai\",\n  \"m4mib-siaaa-aaaan-qaucq-cai\",\n  \"4ch4l-viaaa-aaaan-qa3bq-cai\",\n  \"uldch-7yaaa-aaaan-qa2wq-cai\",\n  \"2d2yc-biaaa-aaaan-qa4ka-cai\",\n];\n","/* eslint-disable no-inner-declarations */\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useAppSelector, useAppDispatch } from \"store/hooks\";\nimport { Bound, BIG_INT_ZERO, FIELD } from \"constants/swap\";\nimport { resultFormat } from \"@w2e/utils\";\nimport {\n  FeeAmount,\n  TickMath,\n  tickToPrice,\n  TICK_SPACINGS,\n  priceToClosestTick,\n  encodeSqrtRatioX96,\n  Pool,\n  Position,\n  Token,\n  Rounding,\n  Price,\n  CurrencyAmount,\n  nearestUsableTick,\n} from \"@w2e/swap-sdk\";\nimport { tryParseTick } from \"utils/swap/mint\";\nimport { tryParseAmount } from \"utils/swap\";\nimport { getTickToPrice } from \"utils/swap/getTickToPrice\";\nimport { usePool, PoolState } from \"hooks/swap/v2/usePools\";\nimport { JSBI } from \"utils/index\";\nimport { useUserTokens, useUserV1Tokens, useUserInvalidTokens } from \"hooks/swap/v2/useSwapCalls\";\nimport { swapPositionManager, swapFactory, swapPositionManagerV1, swapFactoryV1 } from \"actor/swapV2\";\nimport { useCurrencyBalance } from \"hooks/token/useTokenBalance\";\nimport { maxAmountSpend } from \"utils/swap/maxAmountSpend\";\nimport { t } from \"@lingui/macro\";\nimport { PositionResult, UserPosition } from \"types/swapv2\";\nimport { useAccountPrincipal } from \"store/auth/hooks\";\nimport { useUpdatePoolTokenStandardCallback } from \"hooks/swap/v2/index\";\nimport { DISABLE_ADD_LIQUIDITY_IDS } from \"constants/v2\";\nimport {\n  updateUserPositions,\n  updateFiled,\n  updateLeftRange,\n  updateRightRange,\n  updateStartPrice,\n  updateFullRange,\n  resetMintState,\n} from \"./actions\";\n\nexport function useUserV1Positions() {\n  const [loading, setLoading] = useState(true);\n  const updateTokenStandard = useUpdatePoolTokenStandardCallback();\n  const { result: tokenIds } = useUserV1Tokens();\n\n  const [positions, setPositions] = useState<(UserPosition | undefined)[]>([]);\n\n  useEffect(() => {\n    setLoading(true);\n\n    if (tokenIds && tokenIds.length > 0) {\n      const positions: (PositionResult | undefined)[] = [];\n      let done = 0;\n\n      // @ts-ignore\n      function trigger() {\n        if (done === tokenIds?.length) {\n          const positionsWithTokenIds: (UserPosition | undefined)[] = [];\n\n          positions.forEach((position, index) => {\n            if (position) {\n              positionsWithTokenIds.push({\n                ...position,\n                id: tokenIds[index],\n              });\n            }\n          });\n\n          setPositions(positionsWithTokenIds);\n\n          setLoading(false);\n        }\n      }\n\n      tokenIds.forEach(async (tokenId, index) => {\n        (await swapPositionManagerV1())\n          .positions(tokenId)\n          .then(async (result: any) => {\n            const pool = resultFormat<PositionResult>(result).data;\n            if (pool) {\n              const poolId = await (\n                await swapFactoryV1()\n              ).getPool(`${pool?.token0}_${pool?.token1}_${String(pool?.fee)}`);\n              await updateTokenStandard(poolId, pool.token0);\n              await updateTokenStandard(poolId, pool.token1);\n            }\n            positions[index] = pool;\n            done++;\n            trigger();\n          })\n          .catch((err: Error) => {\n            done++;\n            trigger();\n            positions[index] = undefined;\n            console.error(err);\n          });\n      });\n    } else {\n      setLoading(false);\n      setPositions([]);\n    }\n  }, [tokenIds, setLoading]);\n\n  return useMemo(\n    () => ({\n      loading,\n      result: positions,\n    }),\n    [loading, positions],\n  );\n}\n\nexport function useQueryUserPositions() {\n  const dispatch = useAppDispatch();\n  const [loading, setLoading] = useState(true);\n  const updateTokenStandard = useUpdatePoolTokenStandardCallback();\n  const { result: tokenIds } = useUserTokens();\n\n  useEffect(() => {\n    setLoading(true);\n\n    if (tokenIds && tokenIds.length > 0) {\n      const positions: (PositionResult | undefined)[] = [];\n      let done = 0;\n\n      // @ts-ignore\n      function trigger() {\n        if (done === tokenIds?.length) {\n          const positionsWithTokenIds: (UserPosition | undefined)[] = [];\n\n          positions.forEach((position, index) => {\n            if (position) {\n              positionsWithTokenIds.push({\n                ...position,\n                id: tokenIds[index],\n              });\n            }\n          });\n\n          dispatch(updateUserPositions(positionsWithTokenIds));\n          setLoading(false);\n        }\n      }\n\n      tokenIds.forEach(async (tokenId, index) => {\n        (await swapPositionManager())\n          .positions(tokenId)\n          .then(async (result: any) => {\n            const pool = resultFormat<PositionResult>(result).data;\n\n            if (pool) {\n              const poolId = await (\n                await swapFactory()\n              ).getPool(`${pool?.token0}_${pool?.token1}_${String(pool?.fee)}`);\n\n              await updateTokenStandard(poolId, pool.token0);\n              await updateTokenStandard(poolId, pool.token1);\n            }\n\n            positions[index] = pool;\n            done++;\n            trigger();\n          })\n          .catch((err: Error) => {\n            done++;\n            trigger();\n            positions[index] = undefined;\n            console.error(err);\n          });\n      });\n    } else {\n      setLoading(false);\n      dispatch(updateUserPositions([]));\n    }\n  }, [dispatch, tokenIds, setLoading]);\n\n  return loading;\n}\n\nexport function useUserInvalidPositions() {\n  const [positions, setPositions] = useState<(UserPosition | undefined)[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const { result: tokenIds, loading: loading1 } = useUserInvalidTokens();\n\n  useEffect(() => {\n    if (tokenIds?.length) {\n      setLoading(true);\n\n      const positions: (PositionResult | undefined)[] = [];\n      let done = 0;\n\n      // @ts-ignore\n      function trigger() {\n        if (done === tokenIds?.length) {\n          const positionsWithTokenIds: (UserPosition | undefined)[] = [];\n\n          positions.forEach((position, index) => {\n            if (position) {\n              positionsWithTokenIds.push({\n                ...position,\n                id: tokenIds[index],\n              });\n            }\n          });\n\n          setPositions(positionsWithTokenIds);\n\n          setLoading(false);\n        }\n      }\n\n      tokenIds.forEach(async (tokenId, index) => {\n        (await swapPositionManager())\n          .invalidPositions(tokenId)\n          .then((result: any) => {\n            positions[index] = resultFormat<PositionResult>(result).data;\n            done++;\n            trigger();\n          })\n          .catch((err: Error) => {\n            done++;\n            trigger();\n            positions[index] = undefined;\n            console.error(err);\n          });\n      });\n    }\n  }, [tokenIds]);\n\n  return useMemo(\n    () => ({\n      loading: loading || loading1,\n      positions,\n    }),\n    [loading, loading1, positions],\n  );\n}\n\nexport function useUserPositions() {\n  return useAppSelector((state) => state.swapV2Liquidity.userPositions);\n}\n\nexport function useMintState() {\n  return useAppSelector((state) => state.swapV2Liquidity);\n}\n\nexport function useResetMintState() {\n  const dispatch = useAppDispatch();\n  return useCallback(() => {\n    dispatch(resetMintState());\n  }, [dispatch]);\n}\n\nexport function useMintInfo(\n  currencyA: Token | undefined,\n  currencyB: Token | undefined,\n  feeAmount: FeeAmount | undefined,\n  baseCurrency: Token | undefined,\n  existingPosition?: Position,\n  inverted?: boolean | undefined,\n) {\n  const {\n    independentField,\n    typedValue,\n    leftRangeValue: leftRangeTypedValue,\n    rightRangeValue: rightRangeTypedValue,\n    startPrice,\n  } = useMintState();\n\n  const dependentField = independentField === FIELD.CURRENCY_A ? FIELD.CURRENCY_B : FIELD.CURRENCY_A;\n\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency],\n  );\n\n  const currencies = useMemo(\n    () => ({\n      [FIELD.CURRENCY_A]: currencyA,\n      [FIELD.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB],\n  );\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB],\n  );\n\n  const principal = useAccountPrincipal();\n  const { result: tokenABalance } = useCurrencyBalance(principal, tokenA);\n  const { result: tokenBBalance } = useCurrencyBalance(principal, tokenB);\n\n  const currencyBalances = {\n    [FIELD.CURRENCY_A]: tokenABalance,\n    [FIELD.CURRENCY_B]: tokenBBalance,\n  };\n\n  const [poolState, pool] = usePool(currencies[FIELD.CURRENCY_A], currencies[FIELD.CURRENCY_B], feeAmount);\n\n  const noLiquidity = poolState === PoolState.NOT_EXISTS;\n  const poolLoading = poolState === PoolState.LOADING;\n\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0));\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseAmount(startPrice || \"0.1\", invertPrice ? token0 : token1);\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseAmount(\"1\", invertPrice ? token1 : token0);\n\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient,\n              )\n            : undefined;\n\n        return (invertPrice ? price?.invert() : price) ?? undefined;\n      }\n      return undefined;\n    }\n    // get the amount of quote currency\n    return pool && token0 ? pool.priceOf(token0) : undefined;\n  }, [noLiquidity, startPrice, invertPrice, token1, token0, pool]);\n\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined;\n    const invalid =\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      );\n    return invalid;\n  }, [price]);\n\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price);\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick);\n\n      return new Pool(\"\", tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, []);\n    }\n    return undefined;\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB]);\n\n  const poolForPosition = pool ?? mockPool;\n\n  const tickSpaceLimits = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount],\n  );\n\n  const ticks = useMemo(() => {\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === \"number\"\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === \"boolean\") ||\n            (!invertPrice && typeof leftRangeTypedValue === \"boolean\")\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === \"number\"\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === \"boolean\") ||\n            (invertPrice && typeof leftRangeTypedValue === \"boolean\")\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    };\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n  ]);\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {};\n\n  const _ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount],\n  );\n\n  const ticksAtLimit = useMemo(() => {\n    if (!inverted) return _ticksAtLimit;\n\n    return {\n      [Bound.LOWER]: _ticksAtLimit[Bound.UPPER] ? true : undefined,\n      [Bound.UPPER]: _ticksAtLimit[Bound.LOWER] ? true : undefined,\n    };\n  }, [_ticksAtLimit, inverted]);\n\n  const invalidRange = Boolean(\n    typeof tickLower === \"number\" && typeof tickUpper === \"number\" && tickLower >= tickUpper,\n  );\n\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    };\n  }, [token0, token1, ticks]);\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks;\n\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice)),\n  );\n\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n\n  const dependentAmount = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped;\n    const dependentCurrency = dependentField === FIELD.CURRENCY_B ? currencyB : currencyA;\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === \"number\" &&\n      typeof tickUpper === \"number\" &&\n      poolForPosition\n    ) {\n      if (outOfRange || invalidRange) {\n        return undefined;\n      }\n\n      const position = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true,\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          });\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0;\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient);\n    }\n\n    return undefined;\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ]);\n\n  const parsedAmounts = useMemo(() => {\n    return {\n      [FIELD.CURRENCY_A]: independentField === FIELD.CURRENCY_A ? independentAmount : dependentAmount,\n      [FIELD.CURRENCY_B]: independentField === FIELD.CURRENCY_A ? dependentAmount : independentAmount,\n    };\n  }, [dependentAmount, independentAmount, independentField]);\n\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === \"number\" && poolForPosition && poolForPosition.tickCurrent >= tickUpper,\n  );\n\n  const deposit1Disabled = Boolean(\n    typeof tickLower === \"number\" && poolForPosition && poolForPosition.tickCurrent <= tickLower,\n  );\n\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA)),\n    );\n\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB)),\n    );\n\n  const position = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== \"number\" ||\n      typeof tickUpper !== \"number\" ||\n      invalidRange\n    ) {\n      return undefined;\n    }\n\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? FIELD.CURRENCY_A : FIELD.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO;\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? FIELD.CURRENCY_B : FIELD.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO;\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true, // we want full precision for the theoretical position\n      });\n    }\n    return undefined;\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ]);\n\n  const maxAmounts: { [field in FIELD]?: CurrencyAmount<Token> } = [FIELD.CURRENCY_A, FIELD.CURRENCY_B].reduce(\n    (accumulator, field) => {\n      return {\n        ...accumulator,\n        [field]: maxAmountSpend(currencyBalances[field]),\n      };\n    },\n    {},\n  );\n\n  const atMaxAmounts: { [field in FIELD]?: CurrencyAmount<Token> } = [FIELD.CURRENCY_A, FIELD.CURRENCY_B].reduce(\n    (accumulator, field) => {\n      return {\n        ...accumulator,\n        [field]: maxAmounts[field]?.equalTo(parsedAmounts[field] ?? \"0\"),\n      };\n    },\n    {},\n  );\n\n  let errorMessage: string | undefined;\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? t`Invalid pair`;\n  }\n\n  if (noLiquidity) {\n    errorMessage = t`Please add liquidity in ICPSwap V3`;\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? t`Invalid price input`;\n  }\n\n  if (invalidRange) {\n    errorMessage = errorMessage ?? t`Invalid Range`;\n  }\n\n  if (\n    (!parsedAmounts[FIELD.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[FIELD.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? t`Enter an amount`;\n  }\n\n  const { [FIELD.CURRENCY_A]: currencyAAmount, [FIELD.CURRENCY_B]: currencyBAmount } = parsedAmounts;\n\n  if (currencyAAmount && currencyBalances?.[FIELD.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    errorMessage = `Insufficient ${currencies[FIELD.CURRENCY_A]?.symbol} balance`;\n  }\n\n  if (currencyBAmount && currencyBalances?.[FIELD.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    errorMessage = `Insufficient ${currencies[FIELD.CURRENCY_B]?.symbol} balance`;\n  }\n\n  if (DISABLE_ADD_LIQUIDITY_IDS.includes(pool?.id ?? \"\")) {\n    errorMessage = t`Please add liquidity in ICPSwap V3`;\n  }\n\n  return {\n    ticks,\n    pricesAtTicks,\n    invalidRange,\n    outOfRange,\n    invalidPrice,\n    parsedAmounts,\n    dependentField,\n    depositADisabled,\n    depositBDisabled,\n    ticksAtLimit,\n    errorMessage,\n    position,\n    price,\n    invertPrice,\n    pool,\n    noLiquidity,\n    currencyBalances,\n    atMaxAmounts,\n    maxAmounts,\n    poolLoading,\n  };\n}\n\nexport function useMintHandlers(noLiquidity: boolean) {\n  const dispatch = useAppDispatch();\n\n  const onFieldAInput = useCallback(\n    (value: string) => {\n      dispatch(\n        updateFiled({\n          field: FIELD.CURRENCY_A,\n          typedValue: value,\n        }),\n      );\n    },\n    [dispatch, noLiquidity],\n  );\n\n  const onFieldBInput = useCallback(\n    (value: string) => {\n      dispatch(\n        updateFiled({\n          field: FIELD.CURRENCY_B,\n          typedValue: value,\n        }),\n      );\n    },\n    [dispatch, noLiquidity],\n  );\n\n  const onLeftRangeInput = useCallback(\n    (value) => {\n      dispatch(updateLeftRange(value));\n    },\n    [dispatch],\n  );\n\n  const onRightRangeInput = useCallback(\n    (value) => {\n      dispatch(updateRightRange(value));\n    },\n    [dispatch],\n  );\n\n  const onStartPriceInput = useCallback(\n    (value) => {\n      dispatch(updateStartPrice(value));\n    },\n    [dispatch],\n  );\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  };\n}\n\nexport function useRangeCallbacks(\n  baseCurrency: Token | undefined,\n  quoteCurrency: Token | undefined,\n  feeAmount: FeeAmount,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool: Pool | undefined | null,\n) {\n  const dispatch = useAppDispatch();\n\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency]);\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency]);\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(updateFullRange());\n  }, [dispatch]);\n\n  return {\n    getDecrementLower,\n    getIncrementLower,\n    getDecrementUpper,\n    getIncrementUpper,\n    getSetFullRange,\n  };\n}\n","import { Token, Price, tickToPrice } from \"@w2e/swap-sdk\";\n\nexport function getTickToPrice(baseToken?: Token, quoteToken?: Token, tick?: number): Price<Token, Token> | undefined {\n  if (!baseToken || !quoteToken || typeof tick !== \"number\") return undefined;\n  return tickToPrice(baseToken, quoteToken, tick);\n}\n","import { Token, CurrencyAmount } from \"@w2e/swap-sdk\";\n\n/**\n * Given some token amount, return the max that can be spent of it\n * @param currencyAmount to return max of\n */\nexport function maxAmountSpend(currencyAmount?: CurrencyAmount<Token>): CurrencyAmount<Token> | undefined {\n  if (!currencyAmount) return undefined;\n\n  const maxAmountSubFee = currencyAmount.subtract(\n    CurrencyAmount.fromRawAmount(currencyAmount.currency, currencyAmount.currency.transFee * 2),\n  );\n\n  return maxAmountSubFee;\n}\n","import {\n  Price,\n  Token,\n  priceToClosestTick,\n  nearestUsableTick,\n  FeeAmount,\n  TICK_SPACINGS,\n  encodeSqrtRatioX96,\n  TickMath,\n} from \"@w2e/swap-sdk\";\nimport JSBI from \"jsbi\";\n\nexport function tryParsePrice(baseToken?: Token, quoteToken?: Token, value?: string) {\n  if (!baseToken || !quoteToken || !value) {\n    return undefined;\n  }\n\n  if (!value.match(/^\\d*\\.?\\d+$/)) {\n    return undefined;\n  }\n\n  const [whole, fraction] = value.split(\".\");\n\n  const decimals = fraction?.length ?? 0;\n  const withoutDecimals = JSBI.BigInt((whole ?? \"\") + (fraction ?? \"\"));\n\n  return new Price(\n    baseToken,\n    quoteToken,\n    JSBI.multiply(JSBI.BigInt(10 ** decimals), JSBI.BigInt(10 ** baseToken.decimals)),\n    JSBI.multiply(withoutDecimals, JSBI.BigInt(10 ** quoteToken.decimals)),\n  );\n}\n\nexport function tryParseTick(\n  baseToken?: Token,\n  quoteToken?: Token,\n  feeAmount?: FeeAmount,\n  value?: string,\n): number | undefined {\n  if (!baseToken || !quoteToken || !feeAmount || !value) {\n    return undefined;\n  }\n\n  const price = tryParsePrice(baseToken, quoteToken, value);\n\n  if (!price) {\n    return undefined;\n  }\n\n  let tick: number;\n\n  // check price is within min/max bounds, if outside return min/max\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator);\n\n  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {\n    tick = TickMath.MAX_TICK;\n  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {\n    tick = TickMath.MIN_TICK;\n  } else {\n    // this function is agnostic to the base, will always return the correct tick\n    tick = priceToClosestTick(price);\n  }\n\n  return nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n}\n"],"names":["useUpdatePoolTokenStandardCallback","updateTokenStandard","useUpdateTokenStandard","useCallback","async","poolId","tokenId","getTokenStandard","standard","getPoolTokenStandard","canisterId","DISABLE_ADD_LIQUIDITY_IDS","useUserV1Positions","loading","setLoading","useState","result","tokenIds","useUserV1Tokens","positions","setPositions","useEffect","length","done","trigger","positionsWithTokenIds","forEach","position","index","push","id","swapPositionManagerV1","then","pool","resultFormat","data","swapFactoryV1","getPool","concat","token0","token1","String","fee","catch","err","undefined","console","error","useMemo","useQueryUserPositions","dispatch","useAppDispatch","useUserTokens","updateUserPositions","swapPositionManager","swapFactory","useUserPositions","useAppSelector","state","swapV2Liquidity","userPositions","useMintState","useResetMintState","resetMintState","useMintInfo","currencyA","currencyB","feeAmount","baseCurrency","existingPosition","inverted","_currencyBalances$FIE","_currencyBalances$FIE2","_pool$id","independentField","typedValue","leftRangeValue","leftRangeTypedValue","rightRangeValue","rightRangeTypedValue","startPrice","dependentField","FIELD","CURRENCY_A","CURRENCY_B","tokenA","tokenB","baseToken","wrapped","currencies","sortsBefore","principal","useAccountPrincipal","tokenABalance","useCurrencyBalance","tokenBBalance","currencyBalances","poolState","usePool","noLiquidity","PoolState","NOT_EXISTS","poolLoading","LOADING","invertPrice","Boolean","equals","price","priceOf","parsedQuoteAmount","tryParseAmount","_ref","baseAmount","Price","currency","quotient","invert","invalidPrice","sqrtRatioX96","encodeSqrtRatioX96","numerator","denominator","JSBI","greaterThanOrEqual","TickMath","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","priceToClosestTick","currentSqrt","getSqrtRatioAtTick","Pool","BigInt","poolForPosition","tickSpaceLimits","Bound","LOWER","nearestUsableTick","MIN_TICK","TICK_SPACINGS","UPPER","MAX_TICK","ticks","tickLower","tryParseTick","toString","tickUpper","_ticksAtLimit","ticksAtLimit","invalidRange","pricesAtTicks","getTickToPrice","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","Position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","CurrencyAmount","fromRawAmount","parsedAmounts","deposit0Disabled","tickCurrent","deposit1Disabled","depositADisabled","depositBDisabled","_parsedAmounts","_parsedAmounts2","BIG_INT_ZERO","fromAmounts","maxAmounts","reduce","accumulator","field","maxAmountSpend","atMaxAmounts","_maxAmounts$field","_parsedAmounts$field","equalTo","errorMessage","_errorMessage","_errorMessage2","_errorMessage3","_errorMessage4","INVALID","i18n","_","currencyAAmount","currencyBAmount","_currencies$FIELD$CUR","_currencies$FIELD$CUR2","symbol","includes","useMintHandlers","onFieldAInput","value","updateFiled","onFieldBInput","onLeftRangeInput","updateLeftRange","onRightRangeInput","updateRightRange","onStartPriceInput","updateStartPrice","useRangeCallbacks","quoteCurrency","quoteToken","getDecrementLower","tickToPrice","toSignificant","Rounding","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange","updateFullRange","tick","currencyAmount","subtract","transFee","_fraction$length","match","whole","fraction","split","decimals","withoutDecimals","tryParsePrice"],"sourceRoot":""}